"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployTimeLookup = void 0;
const cxapi = require("@aws-cdk/cx-api");
const region_info_1 = require("@aws-cdk/region-info");
const cfn_mapping_1 = require("../cfn-mapping");
const cfn_pseudo_1 = require("../cfn-pseudo");
/**
 * Make sure a CfnMapping exists in the given stack with the lookup values for the given fact
 *
 * Add to an existing CfnMapping if possible.
 */
function deployTimeLookup(stack, factName, lookupMap, defaultValue) {
    // If there are no lookups, just return the default
    if (Object.values(lookupMap).length === 0) {
        if (defaultValue === undefined) {
            throw new Error(`region-info: don't have any information for ${factName}. Use 'Fact.register' to provide values, or add partitions to the '${cxapi.TARGET_PARTITIONS}' context value.`);
        }
        return defaultValue;
    }
    // If the tokenized representation of all values is the same, we can just
    // return the value directly and don't need to produce an actual map.
    const pattern = findValuePattern(lookupMap);
    if (pattern !== undefined) {
        return pattern;
    }
    // Derive map name and lookup key from the factName, splitting on ':' if it exists
    const [factClass, factParam] = factName.includes(':')
        ? factName.split(':')
        : [factName, 'value'];
    const mapId = `${ucfirst(factClass)}Map`;
    const factKey = factParam.replace(/[^a-zA-Z0-9]/g, 'x');
    let mapping = stack.node.tryFindChild(mapId);
    if (!mapping) {
        mapping = new cfn_mapping_1.CfnMapping(stack, mapId);
    }
    for (const [region, value] of Object.entries(lookupMap)) {
        mapping.setValue(region, factKey, value);
    }
    return mapping.findInMap(cfn_pseudo_1.Aws.REGION, factKey);
}
exports.deployTimeLookup = deployTimeLookup;
function ucfirst(x) {
    return `${x.slice(0, 1).toUpperCase()}${x.slice(1)}`;
}
/**
 * Try to detect if all values in the map follow the same pattern
 *
 * Do this by replacing region and URLSuffix values in the found strings
 * with their token variant. If at the end all strings have the same format,
 * we can simplify to just the single value.
 *
 * This wouldn't have been necessary if the region-info library had encoded the
 * pattern information instead of the literal values... but let's do it here now.
 */
function findValuePattern(regionMap) {
    const simplified = { ...regionMap };
    // If they all contain URL_SUFFIX, substitute it, but only if the value is different
    // among some values in the list (we don't want to tokenize unnecessarily, i.e. we don't
    // want to replace `amazonaws.com` with URL_SUFFIX if it's not necessary)
    const urlSuffixes = Object.keys(simplified).map(urlSuffix);
    if (!allSame(urlSuffixes) && Object.entries(simplified).every(([region, value]) => value.includes(urlSuffix(region)))) {
        for (const region in simplified) {
            simplified[region] = replaceAll(simplified[region], urlSuffix(region), cfn_pseudo_1.Aws.URL_SUFFIX);
        }
    }
    // If they all contain REGION, substitute it (no need to do the "is everything different"
    // check, this is true by design for these values)
    if (Object.entries(simplified).every(([region, value]) => value.includes(region))) {
        for (const region in simplified) {
            simplified[region] = replaceAll(simplified[region], region, cfn_pseudo_1.Aws.REGION);
        }
    }
    // If the values are now all the same, return the singleton value
    const values = Object.values(simplified);
    if (allSame(values)) {
        return values[0];
    }
    // Otherwise we failed
    return undefined;
}
function allSame(xs) {
    return xs.every((x) => x === xs[0]);
}
function urlSuffix(region) {
    var _a, _b;
    return (_b = (_a = region_info_1.RegionInfo.get(region)) === null || _a === void 0 ? void 0 : _a.domainSuffix) !== null && _b !== void 0 ? _b : 'amazonaws.com';
}
function replaceAll(x, pat, replacement) {
    return x.split(pat).join(replacement);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVnaW9uLWxvb2t1cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlZ2lvbi1sb29rdXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUNBQXlDO0FBQ3pDLHNEQUFrRDtBQUNsRCxnREFBNEM7QUFDNUMsOENBQW9DO0FBR3BDOzs7O0dBSUc7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxLQUFZLEVBQUUsUUFBZ0IsRUFBRSxTQUFpQyxFQUFFLFlBQXFCO0lBQ3ZILG1EQUFtRDtJQUNuRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUN6QyxJQUFJLFlBQVksS0FBSyxTQUFTLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQywrQ0FBK0MsUUFBUSxzRUFBc0UsS0FBSyxDQUFDLGlCQUFpQixrQkFBa0IsQ0FBQyxDQUFDO1NBQ3pMO1FBQ0QsT0FBTyxZQUFZLENBQUM7S0FDckI7SUFFRCx5RUFBeUU7SUFDekUscUVBQXFFO0lBQ3JFLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzVDLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtRQUN6QixPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUVELGtGQUFrRjtJQUNsRixNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO1FBQ25ELENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFVLENBQUM7SUFFakMsTUFBTSxLQUFLLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUN6QyxNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV4RCxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQTJCLENBQUM7SUFDdkUsSUFBSSxDQUFDLE9BQU8sRUFBRTtRQUNaLE9BQU8sR0FBRyxJQUFJLHdCQUFVLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsS0FBSyxNQUFNLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDdkQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzFDO0lBQ0QsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLGdCQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2hELENBQUM7QUFoQ0QsNENBZ0NDO0FBRUQsU0FBUyxPQUFPLENBQUMsQ0FBUztJQUN4QixPQUFPLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ3ZELENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxTQUFTLGdCQUFnQixDQUFDLFNBQWlDO0lBQ3pELE1BQU0sVUFBVSxHQUEyQixFQUFFLEdBQUcsU0FBUyxFQUFFLENBQUM7SUFFNUQsb0ZBQW9GO0lBQ3BGLHdGQUF3RjtJQUN4Rix5RUFBeUU7SUFDekUsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDM0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDckgsS0FBSyxNQUFNLE1BQU0sSUFBSSxVQUFVLEVBQUU7WUFDL0IsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLGdCQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDeEY7S0FDRjtJQUVELHlGQUF5RjtJQUN6RixrREFBa0Q7SUFDbEQsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7UUFDakYsS0FBSyxNQUFNLE1BQU0sSUFBSSxVQUFVLEVBQUU7WUFDL0IsVUFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLGdCQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDekU7S0FDRjtJQUVELGlFQUFpRTtJQUNqRSxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ25CLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xCO0lBRUQsc0JBQXNCO0lBQ3RCLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRCxTQUFTLE9BQU8sQ0FBQyxFQUFZO0lBQzNCLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RDLENBQUM7QUFFRCxTQUFTLFNBQVMsQ0FBQyxNQUFjOztJQUMvQixtQkFBTyx3QkFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsMENBQUUsWUFBWSxtQ0FBSSxlQUFlLENBQUM7QUFDakUsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFDLENBQVMsRUFBRSxHQUFXLEVBQUUsV0FBbUI7SUFDN0QsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN4QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IFJlZ2lvbkluZm8gfSBmcm9tICdAYXdzLWNkay9yZWdpb24taW5mbyc7XG5pbXBvcnQgeyBDZm5NYXBwaW5nIH0gZnJvbSAnLi4vY2ZuLW1hcHBpbmcnO1xuaW1wb3J0IHsgQXdzIH0gZnJvbSAnLi4vY2ZuLXBzZXVkbyc7XG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJy4uL3N0YWNrJztcblxuLyoqXG4gKiBNYWtlIHN1cmUgYSBDZm5NYXBwaW5nIGV4aXN0cyBpbiB0aGUgZ2l2ZW4gc3RhY2sgd2l0aCB0aGUgbG9va3VwIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGZhY3RcbiAqXG4gKiBBZGQgdG8gYW4gZXhpc3RpbmcgQ2ZuTWFwcGluZyBpZiBwb3NzaWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcGxveVRpbWVMb29rdXAoc3RhY2s6IFN0YWNrLCBmYWN0TmFtZTogc3RyaW5nLCBsb29rdXBNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sIGRlZmF1bHRWYWx1ZT86IHN0cmluZykge1xuICAvLyBJZiB0aGVyZSBhcmUgbm8gbG9va3VwcywganVzdCByZXR1cm4gdGhlIGRlZmF1bHRcbiAgaWYgKE9iamVjdC52YWx1ZXMobG9va3VwTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVnaW9uLWluZm86IGRvbid0IGhhdmUgYW55IGluZm9ybWF0aW9uIGZvciAke2ZhY3ROYW1lfS4gVXNlICdGYWN0LnJlZ2lzdGVyJyB0byBwcm92aWRlIHZhbHVlcywgb3IgYWRkIHBhcnRpdGlvbnMgdG8gdGhlICcke2N4YXBpLlRBUkdFVF9QQVJUSVRJT05TfScgY29udGV4dCB2YWx1ZS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIC8vIElmIHRoZSB0b2tlbml6ZWQgcmVwcmVzZW50YXRpb24gb2YgYWxsIHZhbHVlcyBpcyB0aGUgc2FtZSwgd2UgY2FuIGp1c3RcbiAgLy8gcmV0dXJuIHRoZSB2YWx1ZSBkaXJlY3RseSBhbmQgZG9uJ3QgbmVlZCB0byBwcm9kdWNlIGFuIGFjdHVhbCBtYXAuXG4gIGNvbnN0IHBhdHRlcm4gPSBmaW5kVmFsdWVQYXR0ZXJuKGxvb2t1cE1hcCk7XG4gIGlmIChwYXR0ZXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG4gIC8vIERlcml2ZSBtYXAgbmFtZSBhbmQgbG9va3VwIGtleSBmcm9tIHRoZSBmYWN0TmFtZSwgc3BsaXR0aW5nIG9uICc6JyBpZiBpdCBleGlzdHNcbiAgY29uc3QgW2ZhY3RDbGFzcywgZmFjdFBhcmFtXSA9IGZhY3ROYW1lLmluY2x1ZGVzKCc6JylcbiAgICA/IGZhY3ROYW1lLnNwbGl0KCc6JylcbiAgICA6IFtmYWN0TmFtZSwgJ3ZhbHVlJ10gYXMgY29uc3Q7XG5cbiAgY29uc3QgbWFwSWQgPSBgJHt1Y2ZpcnN0KGZhY3RDbGFzcyl9TWFwYDtcbiAgY29uc3QgZmFjdEtleSA9IGZhY3RQYXJhbS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJ3gnKTtcblxuICBsZXQgbWFwcGluZyA9IHN0YWNrLm5vZGUudHJ5RmluZENoaWxkKG1hcElkKSBhcyBDZm5NYXBwaW5nIHwgdW5kZWZpbmVkO1xuICBpZiAoIW1hcHBpbmcpIHtcbiAgICBtYXBwaW5nID0gbmV3IENmbk1hcHBpbmcoc3RhY2ssIG1hcElkKTtcbiAgfVxuICBmb3IgKGNvbnN0IFtyZWdpb24sIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhsb29rdXBNYXApKSB7XG4gICAgbWFwcGluZy5zZXRWYWx1ZShyZWdpb24sIGZhY3RLZXksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gbWFwcGluZy5maW5kSW5NYXAoQXdzLlJFR0lPTiwgZmFjdEtleSk7XG59XG5cbmZ1bmN0aW9uIHVjZmlyc3QoeDogc3RyaW5nKSB7XG4gIHJldHVybiBgJHt4LnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCl9JHt4LnNsaWNlKDEpfWA7XG59XG5cbi8qKlxuICogVHJ5IHRvIGRldGVjdCBpZiBhbGwgdmFsdWVzIGluIHRoZSBtYXAgZm9sbG93IHRoZSBzYW1lIHBhdHRlcm5cbiAqXG4gKiBEbyB0aGlzIGJ5IHJlcGxhY2luZyByZWdpb24gYW5kIFVSTFN1ZmZpeCB2YWx1ZXMgaW4gdGhlIGZvdW5kIHN0cmluZ3NcbiAqIHdpdGggdGhlaXIgdG9rZW4gdmFyaWFudC4gSWYgYXQgdGhlIGVuZCBhbGwgc3RyaW5ncyBoYXZlIHRoZSBzYW1lIGZvcm1hdCxcbiAqIHdlIGNhbiBzaW1wbGlmeSB0byBqdXN0IHRoZSBzaW5nbGUgdmFsdWUuXG4gKlxuICogVGhpcyB3b3VsZG4ndCBoYXZlIGJlZW4gbmVjZXNzYXJ5IGlmIHRoZSByZWdpb24taW5mbyBsaWJyYXJ5IGhhZCBlbmNvZGVkIHRoZVxuICogcGF0dGVybiBpbmZvcm1hdGlvbiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIHZhbHVlcy4uLiBidXQgbGV0J3MgZG8gaXQgaGVyZSBub3cuXG4gKi9cbmZ1bmN0aW9uIGZpbmRWYWx1ZVBhdHRlcm4ocmVnaW9uTWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc2ltcGxpZmllZDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHsgLi4ucmVnaW9uTWFwIH07XG5cbiAgLy8gSWYgdGhleSBhbGwgY29udGFpbiBVUkxfU1VGRklYLCBzdWJzdGl0dXRlIGl0LCBidXQgb25seSBpZiB0aGUgdmFsdWUgaXMgZGlmZmVyZW50XG4gIC8vIGFtb25nIHNvbWUgdmFsdWVzIGluIHRoZSBsaXN0ICh3ZSBkb24ndCB3YW50IHRvIHRva2VuaXplIHVubmVjZXNzYXJpbHksIGkuZS4gd2UgZG9uJ3RcbiAgLy8gd2FudCB0byByZXBsYWNlIGBhbWF6b25hd3MuY29tYCB3aXRoIFVSTF9TVUZGSVggaWYgaXQncyBub3QgbmVjZXNzYXJ5KVxuICBjb25zdCB1cmxTdWZmaXhlcyA9IE9iamVjdC5rZXlzKHNpbXBsaWZpZWQpLm1hcCh1cmxTdWZmaXgpO1xuICBpZiAoIWFsbFNhbWUodXJsU3VmZml4ZXMpICYmIE9iamVjdC5lbnRyaWVzKHNpbXBsaWZpZWQpLmV2ZXJ5KChbcmVnaW9uLCB2YWx1ZV0pID0+IHZhbHVlLmluY2x1ZGVzKHVybFN1ZmZpeChyZWdpb24pKSkpIHtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBpbiBzaW1wbGlmaWVkKSB7XG4gICAgICBzaW1wbGlmaWVkW3JlZ2lvbl0gPSByZXBsYWNlQWxsKHNpbXBsaWZpZWRbcmVnaW9uXSwgdXJsU3VmZml4KHJlZ2lvbiksIEF3cy5VUkxfU1VGRklYKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGV5IGFsbCBjb250YWluIFJFR0lPTiwgc3Vic3RpdHV0ZSBpdCAobm8gbmVlZCB0byBkbyB0aGUgXCJpcyBldmVyeXRoaW5nIGRpZmZlcmVudFwiXG4gIC8vIGNoZWNrLCB0aGlzIGlzIHRydWUgYnkgZGVzaWduIGZvciB0aGVzZSB2YWx1ZXMpXG4gIGlmIChPYmplY3QuZW50cmllcyhzaW1wbGlmaWVkKS5ldmVyeSgoW3JlZ2lvbiwgdmFsdWVdKSA9PiB2YWx1ZS5pbmNsdWRlcyhyZWdpb24pKSkge1xuICAgIGZvciAoY29uc3QgcmVnaW9uIGluIHNpbXBsaWZpZWQpIHtcbiAgICAgIHNpbXBsaWZpZWRbcmVnaW9uXSA9IHJlcGxhY2VBbGwoc2ltcGxpZmllZFtyZWdpb25dLCByZWdpb24sIEF3cy5SRUdJT04pO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSB2YWx1ZXMgYXJlIG5vdyBhbGwgdGhlIHNhbWUsIHJldHVybiB0aGUgc2luZ2xldG9uIHZhbHVlXG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC52YWx1ZXMoc2ltcGxpZmllZCk7XG4gIGlmIChhbGxTYW1lKHZhbHVlcykpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIHdlIGZhaWxlZFxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBhbGxTYW1lKHhzOiBzdHJpbmdbXSkge1xuICByZXR1cm4geHMuZXZlcnkoKHgpID0+IHggPT09IHhzWzBdKTtcbn1cblxuZnVuY3Rpb24gdXJsU3VmZml4KHJlZ2lvbjogc3RyaW5nKSB7XG4gIHJldHVybiBSZWdpb25JbmZvLmdldChyZWdpb24pPy5kb21haW5TdWZmaXggPz8gJ2FtYXpvbmF3cy5jb20nO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQWxsKHg6IHN0cmluZywgcGF0OiBzdHJpbmcsIHJlcGxhY2VtZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIHguc3BsaXQocGF0KS5qb2luKHJlcGxhY2VtZW50KTtcbn1cblxuIl19