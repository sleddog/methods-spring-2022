{
  "version": 3,
  "sources": ["secret-value.ts"],
  "sourcesContent": ["import { CHECK_SECRET_USAGE } from '../../cx-api';\nimport { CfnDynamicReference, CfnDynamicReferenceService } from './cfn-dynamic-reference';\nimport { CfnParameter } from './cfn-parameter';\nimport { CfnResource } from './cfn-resource';\nimport { FeatureFlags } from './feature-flags';\nimport { CfnReference } from './private/cfn-reference';\nimport { Intrinsic, IntrinsicProps } from './private/intrinsic';\nimport { IResolveContext } from './resolvable';\nimport { Token, Tokenization } from './token';\n\n/**\n * Work with secret values in the CDK\n *\n * Constructs that need secrets will declare parameters of type `SecretValue`.\n *\n * The actual values of these secrets should not be committed to your\n * repository, or even end up in the synthesized CloudFormation template. Instead, you should\n * store them in an external system like AWS Secrets Manager or SSM Parameter\n * Store, and you can reference them by calling `SecretValue.secretsManager()` or\n * `SecretValue.ssmSecure()`.\n *\n * You can use `SecretValue.unsafePlainText()` to construct a `SecretValue` from a\n * literal string, but doing so is highly discouraged.\n *\n * To make sure secret values don't accidentally end up in readable parts\n * of your infrastructure definition (such as the environment variables\n * of an AWS Lambda Function, where everyone who can read the function\n * definition has access to the secret), using secret values directly is not\n * allowed. You must pass them to constructs that accept `SecretValue`\n * properties, which are guaranteed to use the value only in CloudFormation\n * properties that are write-only.\n *\n * If you are sure that what you are doing is safe, you can call\n * `secretValue.unsafeUnwrap()` to access the protected string of the secret\n * value.\n *\n * (If you are writing something like an AWS Lambda Function and need to access\n * a secret inside it, make the API call to `GetSecretValue` directly inside\n * your Lamba's code, instead of using environment variables.)\n */\nexport class SecretValue extends Intrinsic {\n  /**\n   * Test whether an object is a SecretValue\n   */\n  public static isSecretValue(x: any): x is SecretValue {\n    return typeof x === 'object' && x && x[SECRET_VALUE_SYM];\n  }\n\n  /**\n   * Construct a literal secret value for use with secret-aware constructs\n   *\n   * Do not use this method for any secrets that you care about! The value\n   * will be visible to anyone who has access to the CloudFormation template\n   * (via the AWS Console, SDKs, or CLI).\n   *\n   * The only reasonable use case for using this method is when you are testing.\n   *\n   * @deprecated Use `unsafePlainText()` instead.\n   */\n  public static plainText(secret: string): SecretValue {\n    return new SecretValue(secret);\n  }\n\n  /**\n   * Construct a literal secret value for use with secret-aware constructs\n   *\n   * Do not use this method for any secrets that you care about! The value\n   * will be visible to anyone who has access to the CloudFormation template\n   * (via the AWS Console, SDKs, or CLI).\n   *\n   * The only reasonable use case for using this method is when you are testing.\n   */\n  public static unsafePlainText(secret: string): SecretValue {\n    return new SecretValue(secret);\n  }\n\n  /**\n   * Creates a `SecretValue` with a value which is dynamically loaded from AWS Secrets Manager.\n   * @param secretId The ID or ARN of the secret\n   * @param options Options\n   */\n  public static secretsManager(secretId: string, options: SecretsManagerSecretOptions = {}): SecretValue {\n    if (!secretId) {\n      throw new Error('secretId cannot be empty');\n    }\n\n    if (!Token.isUnresolved(secretId) && !secretId.startsWith('arn:') && secretId.includes(':')) {\n      throw new Error(`secret id \"${secretId}\" is not an ARN but contains \":\"`);\n    }\n\n    if (options.versionStage && options.versionId) {\n      throw new Error(`verionStage: '${options.versionStage}' and versionId: '${options.versionId}' were both provided but only one is allowed`);\n    }\n\n    const parts = [\n      secretId,\n      'SecretString',\n      options.jsonField || '',\n      options.versionStage || '',\n      options.versionId || '',\n    ];\n\n    const dyref = new CfnDynamicReference(CfnDynamicReferenceService.SECRETS_MANAGER, parts.join(':'));\n    return this.cfnDynamicReference(dyref);\n  }\n\n  /**\n   * Use a secret value stored from a Systems Manager (SSM) parameter.\n   *\n   * @param parameterName The name of the parameter in the Systems Manager\n   * Parameter Store. The parameter name is case-sensitive.\n   *\n   * @param version An integer that specifies the version of the parameter to\n   * use. If you don't specify the exact version, AWS CloudFormation uses the\n   * latest version of the parameter.\n   */\n  public static ssmSecure(parameterName: string, version?: string): SecretValue {\n    return this.cfnDynamicReference(\n      new CfnDynamicReference(CfnDynamicReferenceService.SSM_SECURE,\n        version ? `${parameterName}:${version}` : parameterName));\n  }\n\n  /**\n   * Obtain the secret value through a CloudFormation dynamic reference.\n   *\n   * If possible, use `SecretValue.ssmSecure` or `SecretValue.secretsManager` directly.\n   *\n   * @param ref The dynamic reference to use.\n   */\n  public static cfnDynamicReference(ref: CfnDynamicReference) {\n    return new SecretValue(ref);\n  }\n\n  /**\n   * Obtain the secret value through a CloudFormation parameter.\n   *\n   * Generally, this is not a recommended approach. AWS Secrets Manager is the\n   * recommended way to reference secrets.\n   *\n   * @param param The CloudFormation parameter to use.\n   */\n  public static cfnParameter(param: CfnParameter) {\n    if (!param.noEcho) {\n      throw new Error('CloudFormation parameter must be configured with \"NoEcho\"');\n    }\n\n    return new SecretValue(param.value);\n  }\n\n  /**\n   * Use a resource's output as secret value\n   */\n  public static resourceAttribute(attr: string) {\n    const resolved = Tokenization.reverseCompleteString(attr);\n    if (!resolved || !CfnReference.isCfnReference(resolved) || !CfnResource.isCfnResource(resolved.target)) {\n      throw new Error('SecretValue.resourceAttribute() must be used with a resource attribute');\n    }\n\n    return new SecretValue(attr);\n  }\n\n  private readonly rawValue: any;\n\n  /**\n   * Construct a SecretValue (do not use!)\n   *\n   * Do not use the constructor directly: use one of the factory functions on the class\n   * instead.\n   */\n  constructor(protectedValue: any, options?: IntrinsicProps) {\n    super(protectedValue, options);\n    this.rawValue = protectedValue;\n  }\n\n  /**\n   * Disable usage protection on this secret\n   *\n   * Call this to indicate that you want to use the secret value held by this\n   * object in an unchecked way. If you don't call this method, using the secret\n   * value directly in a string context or as a property value somewhere will\n   * produce an error.\n   *\n   * This method has 'unsafe' in the name on purpose! Make sure that the\n   * construct property you are using the returned value in is does not end up\n   * in a place in your AWS infrastructure where it could be read by anyone\n   * unexpected.\n   *\n   * When in doubt, don't call this method and only pass the object to constructs that\n   * accept `SecretValue` parameters.\n   */\n  public unsafeUnwrap() {\n    return Token.asString(this.rawValue);\n  }\n\n  /**\n   * Resolve the secret\n   *\n   * If the feature flag is not set, resolve as normal. Otherwise, throw a descriptive\n   * error that the usage guard is missing.\n   */\n  public resolve(context: IResolveContext) {\n    if (FeatureFlags.of(context.scope).isEnabled(CHECK_SECRET_USAGE)) {\n      throw new Error(\n        `Synthing a secret value to ${context.documentPath.join('/')}. Using a SecretValue here risks exposing your secret. Only pass SecretValues to constructs that accept a SecretValue property, or call AWS Secrets Manager directly in your runtime code. Call 'secretValue.unsafeUnwrap()' if you understand and accept the risks.`,\n      );\n    }\n    return super.resolve(context);\n  }\n}\n\n/**\n * Options for referencing a secret value from Secrets Manager.\n */\nexport interface SecretsManagerSecretOptions {\n  /**\n   * Specifies the secret version that you want to retrieve by the staging label attached to the version.\n   *\n   * Can specify at most one of `versionId` and `versionStage`.\n   *\n   * @default AWSCURRENT\n   */\n  readonly versionStage?: string;\n\n  /**\n   * Specifies the unique identifier of the version of the secret you want to use.\n   *\n   * Can specify at most one of `versionId` and `versionStage`.\n   *\n   * @default AWSCURRENT\n   */\n  readonly versionId?: string;\n\n  /**\n   * The key of a JSON field to retrieve. This can only be used if the secret\n   * stores a JSON object.\n   *\n   * @default - returns all the content stored in the Secrets Manager secret.\n   */\n  readonly jsonField?: string;\n}\n\nconst SECRET_VALUE_SYM = Symbol.for('@aws-cdk/core.SecretValue');\n\nObject.defineProperty(SecretValue.prototype, SECRET_VALUE_SYM, {\n  value: true,\n  configurable: false,\n  enumerable: false,\n  writable: false,\n});"],
  "mappings": "kNAAA,SAAA,QAAA,cAAA,EACA,wBAAA,QAAA,yBAAA,EAEA,eAAA,QAAA,gBAAA,EACA,gBAAA,QAAA,iBAAA,EACA,gBAAA,QAAA,yBAAA,EACA,YAAA,QAAA,qBAAA,EAEA,QAAA,QAAA,SAAA,EAgCA,MAAa,mBAAoB,aAAA,SAAS,CAiIxC,YAAY,eAAqB,QAAwB,CACvD,MAAM,eAAgB,OAAO,0MAC7B,KAAK,SAAW,qBA/HJ,eAAc,EAAM,CAChC,MAAO,OAAO,IAAM,UAAY,GAAK,EAAE,wBAc3B,WAAU,OAAc,iPACpC,MAAO,IAAI,aAAY,MAAM,QAYjB,iBAAgB,OAAc,CAC1C,MAAO,IAAI,aAAY,MAAM,QAQjB,gBAAe,SAAkB,QAAuC,CAAA,EAAE,yNACtF,GAAI,CAAC,SACH,KAAM,IAAI,OAAM,0BAA0B,EAG5C,GAAI,CAAC,QAAA,MAAM,aAAa,QAAQ,GAAK,CAAC,SAAS,WAAW,MAAM,GAAK,SAAS,SAAS,GAAG,EACxF,KAAM,IAAI,OAAM,cAAc,0CAA0C,EAG1E,GAAI,QAAQ,cAAgB,QAAQ,UAClC,KAAM,IAAI,OAAM,iBAAiB,QAAQ,iCAAiC,QAAQ,uDAAuD,EAG3I,KAAM,OAAQ,CACZ,SACA,eACA,QAAQ,WAAa,GACrB,QAAQ,cAAgB,GACxB,QAAQ,WAAa,IAGjB,MAAQ,GAAI,yBAAA,oBAAoB,wBAAA,2BAA2B,gBAAiB,MAAM,KAAK,GAAG,CAAC,EACjG,MAAO,MAAK,oBAAoB,KAAK,QAazB,WAAU,cAAuB,QAAgB,CAC7D,MAAO,MAAK,oBACV,GAAI,yBAAA,oBAAoB,wBAAA,2BAA2B,WACjD,QAAU,GAAG,iBAAiB,UAAY,aAAa,CAAC,QAUhD,qBAAoB,IAAwB,kNACxD,MAAO,IAAI,aAAY,GAAG,QAWd,cAAa,MAAmB,sMAC5C,GAAI,CAAC,MAAM,OACT,KAAM,IAAI,OAAM,2DAA2D,EAG7E,MAAO,IAAI,aAAY,MAAM,KAAK,QAMtB,mBAAkB,KAAY,CAC1C,KAAM,UAAW,QAAA,aAAa,sBAAsB,IAAI,EACxD,GAAI,CAAC,UAAY,CAAC,gBAAA,aAAa,eAAe,QAAQ,GAAK,CAAC,eAAA,YAAY,cAAc,SAAS,MAAM,EACnG,KAAM,IAAI,OAAM,wEAAwE,EAG1F,MAAO,IAAI,aAAY,IAAI,EAgCtB,cAAY,CACjB,MAAO,SAAA,MAAM,SAAS,KAAK,QAAQ,EAS9B,QAAQ,QAAwB,sMACrC,GAAI,gBAAA,aAAa,GAAG,QAAQ,KAAK,EAAE,UAAU,SAAA,kBAAkB,EAC7D,KAAM,IAAI,OACR,8BAA8B,QAAQ,aAAa,KAAK,GAAG,uQAAuQ,EAGtU,MAAO,OAAM,QAAQ,OAAO,GAtKhC,QAAA,YAAA,mGAyMA,KAAM,kBAAmB,OAAO,IAAI,2BAA2B,EAE/D,OAAO,eAAe,YAAY,UAAW,iBAAkB,CAC7D,MAAO,GACP,aAAc,GACd,WAAY,GACZ,SAAU,GACX",
  "names": []
}
